diff --git a/include/LMS7002M/LMS7002M.h b/include/LMS7002M/LMS7002M.h
index a386699..7d7e52b 100644
--- a/include/LMS7002M/LMS7002M.h
+++ b/include/LMS7002M/LMS7002M.h
@@ -46,12 +46,21 @@ typedef enum
 //! VCO ranges
 #define LMS7002M_CGEN_VCO_LO 2.000e9
 #define LMS7002M_CGEN_VCO_HI 2.700e9
+#if 1
+#define LMS7002M_SXX_VCOL_LO 3800e6
+#define LMS7002M_SXX_VCOL_HI 5222e6
+#define LMS7002M_SXX_VCOM_LO 4961e6
+#define LMS7002M_SXX_VCOM_HI 6754e6
+#define LMS7002M_SXX_VCOH_LO 6306e6
+#define LMS7002M_SXX_VCOH_HI 7714e6
+#else
 #define LMS7002M_SXX_VCOL_LO 3.800e9
 #define LMS7002M_SXX_VCOL_HI 5.222e9
 #define LMS7002M_SXX_VCOM_LO 4.961e9
 #define LMS7002M_SXX_VCOM_HI 6.754e9
 #define LMS7002M_SXX_VCOH_LO 6.306e9
 #define LMS7002M_SXX_VCOH_HI 7.714e9
+#endif
 
 /*!
  * Function typedef for a function that implements SPI register transactions.
diff --git a/src/LMS7002M_sxx.c b/src/LMS7002M_sxx.c
index cebdf75..f813709 100644
--- a/src/LMS7002M_sxx.c
+++ b/src/LMS7002M_sxx.c
@@ -136,6 +136,65 @@ int LMS7002M_set_lo_freq(LMS7002M_t *self, const LMS7002M_dir_t direction, const
     LMS7002M_regs_spi_write(self, 0x011c);
     self->regs->reg_0x011c_reset_n = 1;
     LMS7002M_regs_spi_write(self, 0x011c);
+#if 1
+    /* try first to check if frequency is acceptable */
+    int8_t div_loch;
+    double vco_freq;
+    bool div_loch_vld = false;
+    for (div_loch = 6; div_loch >= 0; div_loch--) {
+        vco_freq = (1 << (div_loch + 1)) * fout;
+        if (vco_freq >= LMS7002M_SXX_VCOL_LO && vco_freq <= LMS7002M_SXX_VCOH_HI) {
+            div_loch_vld = true;
+            break;
+        }
+    }
+
+    if (!div_loch_vld) {
+        printf("requested frequency %lf is out of range\n", fout);
+        return -3;
+    }
+
+    /* now we know frequency is acceptable */
+    uint16_t integerPart;
+    uint32_t fractionalPart;
+
+    const double m_dThrF = 5500e6; //threshold to enable additional divider
+    integerPart = (uint16_t)(vco_freq / (fref * (1 + (vco_freq > m_dThrF))) - 4);
+    fractionalPart = (uint32_t)((vco_freq / (fref * (1 + (vco_freq > m_dThrF))) - (uint32_t)(vco_freq / (fref * (1 + (vco_freq > m_dThrF))))) * 1048576);
+
+    //Modify_SPI_Reg_bits(LMS7param(EN_INTONLY_SDM), 0);
+    self->regs->reg_0x0086_en_intonly_sdm_cgen = 0;
+    LMS7002M_regs_spi_write(self, 0x0086);
+    //Modify_SPI_Reg_bits(LMS7param(INT_SDM), integerPart); //INT_SDM
+    self->regs->reg_0x011e_int_sdm = integerPart;
+    LMS7002M_regs_spi_write(self, 0x011e);
+    //Modify_SPI_Reg_bits(0x011D, 15, 0, fractionalPart & 0xFFFF); //FRAC_SDM[15:0]
+    self->regs->reg_0x011d_frac_sdm = fractionalPart & 0xFFFF;
+    LMS7002M_regs_spi_write(self, 0x011d);
+    //Modify_SPI_Reg_bits(0x011E, 3, 0, (fractionalPart >> 16)); //FRAC_SDM[19:16]
+    self->regs->reg_0x011e_frac_sdm = fractionalPart >> 16;
+    LMS7002M_regs_spi_write(self, 0x011e);
+    //Modify_SPI_Reg_bits(LMS7param(DIV_LOCH), div_loch); //DIV_LOCH
+    self->regs->reg_0x011f_div_loch = div_loch;
+    LMS7002M_regs_spi_write(self, 0x011f);
+    //Modify_SPI_Reg_bits(LMS7param(EN_DIV2_DIVPROG), (VCOfreq > m_dThrF)); //EN_DIV2_DIVPROG
+    self->regs->reg_0x011c_en_div2_divprog = (vco_freq > m_dThrF);
+    LMS7002M_regs_spi_write(self, 0x011c);
+
+
+    LMS7_logf(LMS7_INFO, "INT %d, FRAC %d, DIV_LOCH %d, EN_DIV2_DIVPROG %d",
+                integerPart,
+                fractionalPart,
+                (int16_t)div_loch,
+                (vco_freq > m_dThrF));
+    LMS7_logf(LMS7_INFO, "VCO %.2f MHz, RefClk %.2f MHz", vco_freq/1e6, fref/1e6);
+
+    self->regs->reg_0x011c_pd_vco = 0;
+    self->regs->reg_0x011c_pd_vco_comp = 0;
+    LMS7002M_regs_spi_write(self, 0x011c);
+
+    /* orig */
+#endif
 
     //state for each VCO
     LMS7002M_sxx_tune_state states[3];
diff --git a/src/LMS7002M_vco.c b/src/LMS7002M_vco.c
index b3d3f0e..a9ea5f7 100644
--- a/src/LMS7002M_vco.c
+++ b/src/LMS7002M_vco.c
@@ -155,3 +155,76 @@ int LMS7002M_tune_vco(
     }
     return 0;
 }
+
+int LMS7002M_tune_vco2(
+    LMS7002M_t *self,
+    int *vco_csw_reg,
+    const int vco_csw_addr,
+    int *vco_cmpho_reg,
+    int *vco_cmplo_reg,
+    const int vco_cmp_addr
+)
+{
+    //check comparator under minimum setting
+    *vco_csw_reg = 0;
+    LMS7002M_regs_spi_write(self, vco_csw_addr);
+    LMS7002M_read_vco_cmp(self, vco_cmp_addr);
+    if (*vco_cmpho_reg == 1 && *vco_cmplo_reg == 1)
+    {
+        LMS7_log(LMS7_DEBUG, "VCO select FAIL - too high");
+        return -1;
+    }
+
+    //check comparator under maximum setting
+    *vco_csw_reg = 255;
+    LMS7002M_regs_spi_write(self, vco_csw_addr);
+    LMS7002M_read_vco_cmp(self, vco_cmp_addr);
+    if (*vco_cmpho_reg == 0 && *vco_cmplo_reg == 0)
+    {
+        LMS7_log(LMS7_DEBUG, "VCO select FAIL - too low");
+        return -1;
+    }
+
+    //search both segments of the 8-bit space
+    int lo0, hi0, lo1, hi1;
+    LMS7002M_tune_vco_sweep(self, vco_csw_reg, vco_csw_addr, vco_cmpho_reg, vco_cmplo_reg, vco_cmp_addr, 0, &lo0, &hi0);
+    LMS7002M_tune_vco_sweep(self, vco_csw_reg, vco_csw_addr, vco_cmpho_reg, vco_cmplo_reg, vco_cmp_addr, 128, &lo1, &hi1);
+
+    //determine overall high-low with overlap
+    int csw_lowest, csw_highest;
+    if (hi0 == lo1-1)
+    {
+        csw_lowest = lo0;
+        csw_highest = hi1;
+    }
+
+    //otherwise use bigger range
+    else if ((hi0-lo0) > (hi1-lo1))
+    {
+        csw_lowest = lo0;
+        csw_highest = hi0;
+    }
+    else
+    {
+        csw_lowest = lo1;
+        csw_highest = hi1;
+    }
+
+    //set the midpoint of the search
+    *vco_csw_reg = (csw_highest+csw_lowest)/2;
+    LMS7002M_regs_spi_write(self, vco_csw_addr);
+    LMS7_logf(LMS7_DEBUG, "lowest CSW_VCO %i, highest CSW_VCO %i, CSW_VCO %i", csw_lowest, csw_highest, *vco_csw_reg);
+
+    //check that the vco selection was successful
+    LMS7002M_read_vco_cmp(self, vco_cmp_addr);
+    if (*vco_cmpho_reg != 0 && *vco_cmplo_reg == 0)
+    {
+        LMS7_log(LMS7_DEBUG, "VCO OK");
+    }
+    else
+    {
+        LMS7_log(LMS7_DEBUG, "VCO select FAIL");
+        return -1;
+    }
+    return 0;
+}
